function [x, x_array, er_array] = maximize_falpha(A,a,p,varargin)
% % % Computes x with nonnegative entries that maximizes
% % % f(x) = sum_{ij} a(i,j) mu_a(x(i),x(j))
% % % Citation:  
%           F. Tudisco & D. J. Higham, 
%           A nonlinear spectral method for core-periphery detection

%%%%%%%%
% INPUT 
%   A           :   Adjacency matrix (symmetric)
%   a           :   Paramter alpha defining mu_a
%   p           :   Parameter p. Convergence in esnured for $p>a$
%   tol         :   Tolerance for stopping criterion (default: 1e-8)
%   x0          :   Starting point (default: all ones vector)
%   maxiter     :   Maximum number of iterations (default: 200)
%   verbose     :   Print details

%%%%%%%
% OUTPUT
%   x           :   Vector maximizing f on R_+
%   x_array     :   Sequence of vectors x_k generated by the method
%   er_array    :   Sequence of errors ||x_k-x_k+1||_p of each itaration
    
    if ~issymmetric(A), error('Adjancency matrix is not symmetric'); end

    n  = length(A);
       
    par = inputParser;
    par.addParameter('tol', 1e-8);
    par.addParameter('x0',ones(n,1));
    par.addParameter('verbose', false);
    par.addParameter('maxiter',200);
    par.parse(varargin{:});
    x0 = par.Results.x0;
    tol = par.Results.tol;
    verbose = par.Results.verbose;
    maxiter = par.Results.maxiter;
    
    if verbose
        fprintf('\n# Nonlinear Spectral Method:');
        fprintf('\n-------------------------------');
        fprintf('\nalpha:\t\t%d\np:\t\t%d\ntol:\t\t%d',a,p,tol);
    end
    
    pp = p/(p-1);
    x_array = x0./norm(x0,p); er_array = [];
    tic;
    for k = 1 : maxiter
        y = F(A,x0,a)';
        y = y./norm(y,pp);
        x = y.^(pp/p);
        x_array = [x_array x];
        er_array = [er_array; norm(x-x0,p)];
        if er_array(end) < tol || isnan(er_array(end))
            time = toc;
            if verbose, fprintf('\nnum iter:\t%d', k); end
            if verbose, fprintf('\nexec time:\t%3.5fs', time); end
            break;     
        else
            x0 = x;
        end
    end        
    


function z = phi(x,y,a)
    z = (x.^a + y.^a).^(1/a);



function nabla = F(A,x,a)
    nabla = zeros(1,length(x));
    idx = find(x);
    [row,col,~] = find(A);
    for s = 1:length(idx)
        i = idx(s);
        idx2 = col(row==i);
        for t = 1:length(idx2)
            j = idx2(t);
            nabla(i) = nabla(i) + 2.*A(i,j).*(x(i)./phi(x(i),x(j),a)).^(a-1);
        end
    end

